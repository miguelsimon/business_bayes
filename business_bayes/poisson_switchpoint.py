import unittest

import numpy as np
import pymc3 as pm
import scipy
from numpy import ndarray


def make_switchpoint_model(counts: ndarray, lower_mu: float, upper_mu: float):
    """
    A model that assumes counts are generated by 2 different poisson processes:
    * counts up to switchpoint (not inclusive) ~ Poisson(early_rate)
    * counts from switchpoint on (inclusive) ~ Poisson(late_rate)

    Parameters
    ----------

    counts :
        1 - dimensional array of counts
    lower_mu :
        lower bound for uniform mu prior
    upper_mu :
        upper bound for uniform mu prior

    Returns
    -------

    pm.Model :
        the model instance

    Based on https://docs.pymc.io/notebooks/getting_started.html#Case-study-2:-Coal-mining-disasters
    """
    model = pm.Model()
    with model:
        idxs = np.arange(len(counts))
        lower_idx = idxs[1]
        upper_idx = idxs[-1]
        mid = (upper_idx - lower_idx) // 2

        switchpoint = pm.DiscreteUniform(
            "switchpoint", lower=lower_idx, upper=upper_idx, testval=mid
        )

        early_rate = pm.Uniform("early_rate", lower=lower_mu, upper=upper_mu)
        late_rate = pm.Uniform("late_rate", lower=lower_mu, upper=upper_mu)

        rate = pm.math.switch(switchpoint > idxs, early_rate, late_rate)

        pm.Poisson("counted", rate, observed=counts)
    return model


def make_2_poisson_model(
    counts: ndarray, labels: ndarray, lower_mu: float, upper_mu: float
):
    """
    counts where label == 0 ~ Poisson(mu1)
    counts where label == 1 ~ Poisson(mu2)

    TODO: Get rid of this and just run 2 separate Poisson models
    """
    assert counts.shape == labels.shape
    assert set(labels) == set([0, 1])

    counts1 = counts[labels == 0]
    counts2 = counts[labels == 1]

    model = pm.Model()

    with model:
        mu1 = pm.Uniform("mu1", lower=lower_mu, upper=upper_mu)
        mu2 = pm.Uniform("mu2", lower=lower_mu, upper=upper_mu)

        pm.Poisson("observed_counts1", mu1, observed=counts1)
        pm.Poisson("observed_counts2", mu2, observed=counts2)
    return model


def switchpoint_to_labels(size: int, switchpoint: int) -> ndarray:
    assert switchpoint > 0
    assert switchpoint <= size

    res = np.zeros(size, dtype=int)
    res[switchpoint:] = 1
    return res


class Test(unittest.TestCase):
    def test_switchpoint_model(self):
        counts = np.array([101, 99, 100, 1, 2, 1])
        model = make_switchpoint_model(counts, 0, 1000)
        with model:
            trace = pm.sample(10000)

        switchpoint = scipy.stats.mode(trace["switchpoint"])
        self.assertTrue(switchpoint, 3)

    def test_2poisson_model(self):
        counts = np.array([100, 100, 100, 100, 10, 10, 10, 10])
        labels = np.array([0, 0, 0, 0, 1, 1, 1, 1])
        model = make_2_poisson_model(counts, labels, 0, 1000)

        with model:
            trace = pm.sample(10000)
            mu1_mean = trace["mu1"].mean()
            mu2_mean = trace["mu2"].mean()
            self.assertTrue(abs(mu1_mean - 100) < 5)
            self.assertTrue(abs(mu2_mean - 10) < 5)
            print(
                "2poisson", trace["mu1"].mean(), trace["mu2"].mean(),
            )

    def test_switchpoint_to_labels(self):
        expected = np.array([0, 0, 1])
        res = switchpoint_to_labels(3, 2)

        self.assertTrue((expected == res).all())
